"""
Helper functions for the AutoGen PRD Generation System.

This module provides utility functions for extracting, validating, and saving
artifacts generated by the AutoGen multi-agent system.
"""

import json
import os
import re
from typing import List, Dict, Any, Optional


def extract_json_from_text(text: str) -> Optional[List[Dict[str, Any]]]:
    """
    Extract JSON content from text that may contain markdown fences or other content.
    
    Args:
        text: String that may contain JSON
        
    Returns:
        Parsed JSON object or None if parsing fails
    """
    # Remove markdown code fences
    if '```json' in text:
        json_str = text.split('```json')[1].split('```')[0].strip()
    elif '```' in text:
        json_str = text.split('```')[1].split('```')[0].strip()
    elif text.strip().startswith('[') or text.strip().startswith('{'):
        json_str = text.strip()
    else:
        return None
    
    try:
        return json.loads(json_str)
    except json.JSONDecodeError as e:
        print(f"JSON parsing error: {e}")
        return None


def extract_markdown_content(text: str, marker: str = "# Product Requirements Document") -> Optional[str]:
    """
    Extract markdown content from text, removing any code fences.
    
    Args:
        text: String containing markdown
        marker: Header or marker to identify the markdown content
        
    Returns:
        Clean markdown string or None
    """
    if marker not in text and "## Introduction" not in text:
        return None
    
    # Remove markdown fences if present
    if '```markdown' in text:
        content = text.split('```markdown')[1].split('```')[0].strip()
    elif '```' in text and 'CREATE TABLE' not in text.upper():
        # Only remove fences if it's not SQL
        content = text.split('```')[1].split('```')[0].strip()
    else:
        content = text.strip()
    
    return content


def extract_sql_content(text: str) -> Optional[str]:
    """
    Extract SQL statements from text, handling markdown fences and formatting.
    
    Args:
        text: String containing SQL
        
    Returns:
        Clean SQL string or None
    """
    if 'CREATE TABLE' not in text.upper():
        return None
    
    # Remove markdown fences
    if '```sql' in text:
        sql = text.split('```sql')[1].split('```')[0].strip()
    elif '```' in text:
        sql = text.split('```')[1].split('```')[0].strip()
    else:
        sql = text.strip()
    
    return sql


def validate_user_stories(stories: List[Dict[str, Any]]) -> tuple[bool, List[str]]:
    """
    Validate user stories structure and content.
    
    Args:
        stories: List of user story dictionaries
        
    Returns:
        Tuple of (is_valid, list of error messages)
    """
    if not isinstance(stories, list) or not stories:
        return False, ["Data is not a non-empty list"]
    
    required_keys = ['id', 'persona', 'user_story', 'acceptance_criteria']
    errors = []
    
    for i, story in enumerate(stories):
        # Check if it's a dictionary
        if not isinstance(story, dict):
            errors.append(f"Story at index {i} is not a dictionary")
            continue
        
        # Check for required keys
        missing_keys = [key for key in required_keys if key not in story]
        if missing_keys:
            errors.append(f"Story {i} missing keys: {missing_keys}")
        
        # Validate acceptance criteria
        ac = story.get('acceptance_criteria')
        if not isinstance(ac, list) or not ac:
            errors.append(f"Story {i} has invalid acceptance_criteria (must be non-empty list)")
        
        # Validate user story format
        user_story = story.get('user_story', '')
        if not ('As a' in user_story or 'As an' in user_story):
            errors.append(f"Story {i} doesn't follow 'As a...' format")
    
    return len(errors) == 0, errors


def validate_prd_content(prd_text: str, required_sections: Optional[List[str]] = None) -> tuple[bool, List[str]]:
    """
    Validate PRD contains required sections.
    
    Args:
        prd_text: The PRD markdown content
        required_sections: List of required section headers
        
    Returns:
        Tuple of (is_valid, list of missing sections)
    """
    if required_sections is None:
        required_sections = [
            "Introduction",
            "User Personas", 
            "Features",
            "Success Metrics"
        ]
    
    missing_sections = []
    for section in required_sections:
        # Check for the section as a header
        pattern = f"#+ *{section}"
        if not re.search(pattern, prd_text, re.IGNORECASE):
            missing_sections.append(section)
    
    return len(missing_sections) == 0, missing_sections


def validate_sql_schema(sql_text: str, required_tables: Optional[List[str]] = None) -> tuple[bool, List[str]]:
    """
    Validate SQL schema contains required tables.
    
    Args:
        sql_text: The SQL schema content
        required_tables: List of required table names
        
    Returns:
        Tuple of (is_valid, list of missing tables)
    """
    if required_tables is None:
        required_tables = ['users', 'onboarding_tasks']
    
    missing_tables = []
    for table in required_tables:
        pattern = f"CREATE TABLE.*{table}"
        if not re.search(pattern, sql_text, re.IGNORECASE | re.DOTALL):
            missing_tables.append(table)
    
    return len(missing_tables) == 0, missing_tables


def extract_from_conversation(messages: List[Dict[str, Any]], 
                               content_type: str = 'json') -> Optional[Any]:
    """
    Extract specific content type from AutoGen conversation messages.
    
    Args:
        messages: List of message dictionaries from AutoGen
        content_type: Type of content to extract ('json', 'markdown', 'sql')
        
    Returns:
        Extracted content or None
    """
    for message in reversed(messages):
        content = message.get('content', '')
        
        if content_type == 'json':
            result = extract_json_from_text(content)
            if result:
                return result
                
        elif content_type == 'markdown':
            result = extract_markdown_content(content)
            if result:
                return result
                
        elif content_type == 'sql':
            result = extract_sql_content(content)
            if result:
                return result
    
    return None


def create_validation_report(artifacts: Dict[str, tuple[str, Any]]) -> str:
    """
    Create a validation report for all generated artifacts.
    
    Args:
        artifacts: Dictionary mapping artifact names to (path, content) tuples
        
    Returns:
        Formatted validation report string
    """
    report = ["=" * 80, "ARTIFACT VALIDATION REPORT", "=" * 80, ""]
    
    for name, (path, content) in artifacts.items():
        report.append(f"\n{name}:")
        report.append("-" * 80)
        
        if content is None:
            report.append("âŒ FAILED - No content generated")
            continue
        
        # Validate based on artifact type
        if 'user_stories' in name.lower():
            is_valid, errors = validate_user_stories(content)
            if is_valid:
                report.append(f"âœ… VALID - {len(content)} user stories")
            else:
                report.append(f"âŒ INVALID - {len(errors)} errors:")
                for error in errors:
                    report.append(f"   â€¢ {error}")
                    
        elif 'prd' in name.lower():
            is_valid, missing = validate_prd_content(content)
            if is_valid:
                report.append(f"âœ… VALID - All required sections present")
            else:
                report.append(f"âš ï¸  INCOMPLETE - Missing sections:")
                for section in missing:
                    report.append(f"   â€¢ {section}")
                    
        elif 'schema' in name.lower():
            is_valid, missing = validate_sql_schema(content)
            if is_valid:
                report.append(f"âœ… VALID - All required tables present")
            else:
                report.append(f"âš ï¸  INCOMPLETE - Missing tables:")
                for table in missing:
                    report.append(f"   â€¢ {table}")
        
        report.append(f"ðŸ“ Path: {path}")
    
    report.extend(["", "=" * 80])
    return "\n".join(report)


def get_conversation_summary(messages: List[Dict[str, Any]]) -> str:
    """
    Generate a summary of the agent conversation.
    
    Args:
        messages: List of message dictionaries from AutoGen
        
    Returns:
        Formatted summary string
    """
    summary = ["=" * 80, "CONVERSATION SUMMARY", "=" * 80, ""]
    
    agent_counts = {}
    for message in messages:
        agent = message.get('name', 'Unknown')
        agent_counts[agent] = agent_counts.get(agent, 0) + 1
    
    summary.append(f"Total messages: {len(messages)}")
    summary.append(f"\nMessages by agent:")
    for agent, count in sorted(agent_counts.items(), key=lambda x: x[1], reverse=True):
        summary.append(f"  â€¢ {agent}: {count}")
    
    summary.extend(["", "=" * 80])
    return "\n".join(summary)


class ArtifactTracker:
    """Track and validate artifacts generated during AutoGen workflows."""
    
    def __init__(self, base_dir: str = "artifacts"):
        self.base_dir = base_dir
        self.artifacts = {}
        
    def register(self, name: str, path: str, content: Any):
        """Register a generated artifact."""
        self.artifacts[name] = {
            'path': path,
            'content': content,
            'size': len(str(content)) if content else 0,
            'valid': content is not None
        }
    
    def get_summary(self) -> str:
        """Get a summary of all tracked artifacts."""
        lines = ["Tracked Artifacts:", "-" * 60]
        
        for name, info in self.artifacts.items():
            status = "âœ“" if info['valid'] else "âœ—"
            lines.append(f"{status} {name}")
            lines.append(f"  Path: {info['path']}")
            lines.append(f"  Size: {info['size']} chars")
            lines.append("")
        
        return "\n".join(lines)
    
    def validate_all(self) -> bool:
        """Check if all artifacts are valid."""
        return all(info['valid'] for info in self.artifacts.values())


# Example usage and testing
if __name__ == "__main__":
    print("AutoGen PRD Helpers Module")
    print("=" * 60)
    
    # Test JSON extraction
    test_json = '''
    Here is the JSON:
    ```json
    [
        {"id": 1, "persona": "New Hire", "user_story": "As a new hire...", "acceptance_criteria": ["Given..."]}
    ]
    ```
    '''
    
    result = extract_json_from_text(test_json)
    print(f"\nJSON extraction test: {'âœ“' if result else 'âœ—'}")
    
    # Test validation
    if result:
        is_valid, errors = validate_user_stories(result)
        print(f"Validation test: {'âœ“' if is_valid else 'âœ—'}")
        if errors:
            for error in errors:
                print(f"  - {error}")
    
    print("\n" + "=" * 60)
    print("Helper module loaded successfully!")
